<?xml version="1.0" encoding="UTF-8" ?>
<File name="tecnoparque_dbxdata.code">
<Generated>#+ Data Management from DB schema (tecnoparque)

--------------------------------------------------------------------------------
--This code is generated by the &apos;dbxdata.tcl&apos; template
--Warning: Enter your changes within a &lt;BLOCK&gt; or &lt;POINT&gt; section, otherwise they will be lost.
{&lt;POINT Name=&quot;user.comments&quot;&gt;}
{&lt;/POINT&gt;}

--------------------------------------------------------------------------------
--Importing modules
IMPORT FGL tecnoparque_dbxconstraints
IMPORT FGL libdbappCommon
{&lt;POINT Name=&quot;import&quot;&gt;}
{&lt;/POINT&gt;}

--------------------------------------------------------------------------------
--Database schema
SCHEMA tecnoparque

--------------------------------------------------------------------------------
--CRUD functions

{&lt;BLOCK Name=&quot;fct.usuarios_selectRowByKey&quot;&gt;}
#+ Select a row identified by the primary key in the &quot;usuarios&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      usuarios_c_empresa LIKE usuarios.c_empresa,
      usuarios_nombre LIKE usuarios.nombre
    END RECORD
  DEFINE l_data RECORD LIKE usuarios.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM usuarios
    WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
      AND usuarios.nombre = p_key.usuarios_nombre
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.usuarios_selectRowByKey

{&lt;BLOCK Name=&quot;fct.usuarios_insertRowByKey&quot;&gt;}
#+ Insert a row in the &quot;usuarios&quot; table and return the primary key created
#+
#+ @param p_data - a row data LIKE usuarios.*
#+
#+ @returnType - INTEGER, SMALLINT, VARCHAR2(45)
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, usuarios.c_empresa, usuarios.nombre
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE usuarios.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_usuarios_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
    IF errNo == ERROR_SUCCESS THEN
      TRY
        INSERT INTO usuarios VALUES (p_data.*)
      CATCH
        LET errNo = ERROR_FAILURE
      END TRY
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.c_empresa, p_data.nombre
END FUNCTION
{&lt;/BLOCK&gt;} --fct.usuarios_insertRowByKey

{&lt;BLOCK Name=&quot;fct.usuarios_updateRowByKey&quot;&gt;}
#+ Update a row identified by the primary key in the &quot;usuarios&quot; table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE usuarios.*
#+ @param p_dataT1 - a row data LIKE usuarios.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      usuarios_c_empresa LIKE usuarios.c_empresa,
      usuarios_nombre LIKE usuarios.nombre
    END RECORD
  DEFINE p_dataT0 RECORD LIKE usuarios.*
  DEFINE p_dataT1 RECORD LIKE usuarios.*
  DEFINE l_dataT2 RECORD LIKE usuarios.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != &quot;SQT&quot;) THEN
        SELECT * INTO l_dataT2.* FROM usuarios
          WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
          AND usuarios.nombre = p_key.usuarios_nombre
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_usuarios_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE usuarios
            SET usuarios.* = p_dataT1.*
            WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
          AND usuarios.nombre = p_key.usuarios_nombre
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{&lt;/BLOCK&gt;} --fct.usuarios_updateRowByKey

{&lt;BLOCK Name=&quot;fct.usuarios_deleteRowByKey&quot;&gt;}
#+ Delete a row identified by the primary key in the &quot;usuarios&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      usuarios_c_empresa LIKE usuarios.c_empresa,
      usuarios_nombre LIKE usuarios.nombre
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM usuarios
        WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
        AND usuarios.nombre = p_key.usuarios_nombre
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{&lt;/BLOCK&gt;} --fct.usuarios_deleteRowByKey

{&lt;BLOCK Name=&quot;fct.usuarios_setDefaultValuesFromDBSchema&quot;&gt;}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE usuarios.*

  INITIALIZE l_data.* TO NULL
  LET l_data.nombre = &quot;&quot;
  LET l_data.c_empresa = &quot;&quot;

  RETURN l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.usuarios_setDefaultValuesFromDBSchema

{&lt;BLOCK Name=&quot;fct.empresas_selectRowByKey&quot;&gt;}
#+ Select a row identified by the primary key in the &quot;empresas&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      empresas_c_empresa LIKE empresas.c_empresa
    END RECORD
  DEFINE l_data RECORD LIKE empresas.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM empresas
    WHERE empresas.c_empresa = p_key.empresas_c_empresa
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.empresas_selectRowByKey

{&lt;BLOCK Name=&quot;fct.empresas_insertRowByKey&quot;&gt;}
#+ Insert a row in the &quot;empresas&quot; table and return the primary key created
#+
#+ @param p_data - a row data LIKE empresas.*
#+
#+ @returnType - INTEGER, SMALLINT
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, empresas.c_empresa
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE empresas.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_empresas_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
    IF errNo == ERROR_SUCCESS THEN
      TRY
        INSERT INTO empresas VALUES (p_data.*)
      CATCH
        LET errNo = ERROR_FAILURE
      END TRY
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.c_empresa
END FUNCTION
{&lt;/BLOCK&gt;} --fct.empresas_insertRowByKey

{&lt;BLOCK Name=&quot;fct.empresas_updateRowByKey&quot;&gt;}
#+ Update a row identified by the primary key in the &quot;empresas&quot; table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE empresas.*
#+ @param p_dataT1 - a row data LIKE empresas.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      empresas_c_empresa LIKE empresas.c_empresa
    END RECORD
  DEFINE p_dataT0 RECORD LIKE empresas.*
  DEFINE p_dataT1 RECORD LIKE empresas.*
  DEFINE l_dataT2 RECORD LIKE empresas.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != &quot;SQT&quot;) THEN
        SELECT * INTO l_dataT2.* FROM empresas
          WHERE empresas.c_empresa = p_key.empresas_c_empresa
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_empresas_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE empresas
            SET empresas.* = p_dataT1.*
            WHERE empresas.c_empresa = p_key.empresas_c_empresa
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{&lt;/BLOCK&gt;} --fct.empresas_updateRowByKey

{&lt;BLOCK Name=&quot;fct.empresas_deleteRowByKey&quot;&gt;}
#+ Delete a row identified by the primary key in the &quot;empresas&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      empresas_c_empresa LIKE empresas.c_empresa
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM empresas
        WHERE empresas.c_empresa = p_key.empresas_c_empresa
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{&lt;/BLOCK&gt;} --fct.empresas_deleteRowByKey

{&lt;BLOCK Name=&quot;fct.empresas_setDefaultValuesFromDBSchema&quot;&gt;}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE empresas.*

  INITIALIZE l_data.* TO NULL
  LET l_data.c_empresa = &quot;&quot;
  LET l_data.empresa = &quot;&quot;

  RETURN l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.empresas_setDefaultValuesFromDBSchema

{&lt;BLOCK Name=&quot;fct.carga_jira_selectRowByKey&quot;&gt;}
#+ Select a row identified by the primary key in the &quot;carga_jira&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      carga_jira_id_jira LIKE carga_jira.id_jira
    END RECORD
  DEFINE l_data RECORD LIKE carga_jira.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM carga_jira
    WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.carga_jira_selectRowByKey

{&lt;BLOCK Name=&quot;fct.carga_jira_insertRowByKey&quot;&gt;}
#+ Insert a row in the &quot;carga_jira&quot; table and return the primary key created
#+
#+ @param p_data - a row data LIKE carga_jira.*
#+
#+ @returnType - INTEGER, SERIAL
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, carga_jira.id_jira
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE carga_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL libdbapp_get_sequence(&quot;carga_jira&quot;) RETURNING errNo, p_data.id_jira
    IF errNo == ERROR_SUCCESS THEN
      CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_carga_jira_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
      IF errNo == ERROR_SUCCESS THEN
        TRY
          INSERT INTO carga_jira VALUES (p_data.*)
        CATCH
          LET errNo = ERROR_FAILURE
        END TRY
      END IF
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.id_jira
END FUNCTION
{&lt;/BLOCK&gt;} --fct.carga_jira_insertRowByKey

{&lt;BLOCK Name=&quot;fct.carga_jira_updateRowByKey&quot;&gt;}
#+ Update a row identified by the primary key in the &quot;carga_jira&quot; table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE carga_jira.*
#+ @param p_dataT1 - a row data LIKE carga_jira.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      carga_jira_id_jira LIKE carga_jira.id_jira
    END RECORD
  DEFINE p_dataT0 RECORD LIKE carga_jira.*
  DEFINE p_dataT1 RECORD LIKE carga_jira.*
  DEFINE l_dataT2 RECORD LIKE carga_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != &quot;SQT&quot;) THEN
        SELECT * INTO l_dataT2.* FROM carga_jira
          WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_carga_jira_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE carga_jira
            SET carga_jira.* = p_dataT1.*
            WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{&lt;/BLOCK&gt;} --fct.carga_jira_updateRowByKey

{&lt;BLOCK Name=&quot;fct.carga_jira_deleteRowByKey&quot;&gt;}
#+ Delete a row identified by the primary key in the &quot;carga_jira&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      carga_jira_id_jira LIKE carga_jira.id_jira
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM carga_jira
        WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{&lt;/BLOCK&gt;} --fct.carga_jira_deleteRowByKey

{&lt;BLOCK Name=&quot;fct.carga_jira_setDefaultValuesFromDBSchema&quot;&gt;}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE carga_jira.*

  INITIALIZE l_data.* TO NULL
  LET l_data.id_jira = &quot;&quot;
  LET l_data.key_ = &quot;&quot;
  LET l_data.issue_type = &quot;&quot;
  LET l_data.status_ = &quot;&quot;
  LET l_data.priority = &quot;&quot;
  LET l_data.summary = &quot;&quot;
  LET l_data.description = &quot;&quot;
  LET l_data.reporter = &quot;&quot;
  LET l_data.assignee = &quot;&quot;
  LET l_data.created = &quot;&quot;
  LET l_data.due_date = &quot;&quot;
  LET l_data.updated = &quot;&quot;
  LET l_data.resolved = &quot;&quot;
  LET l_data.labels = &quot;&quot;
  LET l_data.fecha_carga = &quot;&quot;
  LET l_data.hora_carga = &quot;&quot;

  RETURN l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.carga_jira_setDefaultValuesFromDBSchema

{&lt;BLOCK Name=&quot;fct.actividad_jira_selectRowByKey&quot;&gt;}
#+ Select a row identified by the primary key in the &quot;actividad_jira&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      actividad_jira_key_ LIKE actividad_jira.key_
    END RECORD
  DEFINE l_data RECORD LIKE actividad_jira.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM actividad_jira
    WHERE actividad_jira.key_ = p_key.actividad_jira_key_
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.actividad_jira_selectRowByKey

{&lt;BLOCK Name=&quot;fct.actividad_jira_insertRowByKey&quot;&gt;}
#+ Insert a row in the &quot;actividad_jira&quot; table and return the primary key created
#+
#+ @param p_data - a row data LIKE actividad_jira.*
#+
#+ @returnType - INTEGER, VARCHAR2(45)
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, actividad_jira.key_
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE actividad_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_actividad_jira_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
    IF errNo == ERROR_SUCCESS THEN
      TRY
        INSERT INTO actividad_jira VALUES (p_data.*)
      CATCH
        LET errNo = ERROR_FAILURE
      END TRY
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.key_
END FUNCTION
{&lt;/BLOCK&gt;} --fct.actividad_jira_insertRowByKey

{&lt;BLOCK Name=&quot;fct.actividad_jira_updateRowByKey&quot;&gt;}
#+ Update a row identified by the primary key in the &quot;actividad_jira&quot; table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE actividad_jira.*
#+ @param p_dataT1 - a row data LIKE actividad_jira.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      actividad_jira_key_ LIKE actividad_jira.key_
    END RECORD
  DEFINE p_dataT0 RECORD LIKE actividad_jira.*
  DEFINE p_dataT1 RECORD LIKE actividad_jira.*
  DEFINE l_dataT2 RECORD LIKE actividad_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != &quot;SQT&quot;) THEN
        SELECT * INTO l_dataT2.* FROM actividad_jira
          WHERE actividad_jira.key_ = p_key.actividad_jira_key_
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_actividad_jira_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE actividad_jira
            SET actividad_jira.* = p_dataT1.*
            WHERE actividad_jira.key_ = p_key.actividad_jira_key_
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{&lt;/BLOCK&gt;} --fct.actividad_jira_updateRowByKey

{&lt;BLOCK Name=&quot;fct.actividad_jira_deleteRowByKey&quot;&gt;}
#+ Delete a row identified by the primary key in the &quot;actividad_jira&quot; table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      actividad_jira_key_ LIKE actividad_jira.key_
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM actividad_jira
        WHERE actividad_jira.key_ = p_key.actividad_jira_key_
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{&lt;/BLOCK&gt;} --fct.actividad_jira_deleteRowByKey

{&lt;BLOCK Name=&quot;fct.actividad_jira_setDefaultValuesFromDBSchema&quot;&gt;}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE actividad_jira.*

  INITIALIZE l_data.* TO NULL
  LET l_data.c_status = &quot;&quot;
  LET l_data.paso = &quot;&quot;
  LET l_data.key_ = &quot;&quot;
  LET l_data.issue_type = &quot;&quot;
  LET l_data.status = &quot;&quot;
  LET l_data.priority = &quot;&quot;
  LET l_data.summary = &quot;&quot;
  LET l_data.description = &quot;&quot;
  LET l_data.reporter = &quot;&quot;
  LET l_data.assignee = &quot;&quot;
  LET l_data.fecha_del_dia = &quot;&quot;
  LET l_data.fecha_creacion_created = &quot;&quot;
  LET l_data.fecha_inicio = &quot;&quot;
  LET l_data.dias_transcurridos_al_dia = &quot;&quot;
  LET l_data.fecha_prometida__vs_ns = &quot;&quot;
  LET l_data.fecha_prometida__due_date = &quot;&quot;
  LET l_data.dias_ret_vs_f_prom_ns = &quot;&quot;
  LET l_data.dias_ret_vs_f_prom_due_date = &quot;&quot;
  LET l_data.dias_brecha = &quot;&quot;
  LET l_data.fecha_cierre_resolved = &quot;&quot;
  LET l_data.cumplio_ns = &quot;&quot;
  LET l_data.cumplio_fp = &quot;&quot;
  LET l_data.dias_efectivos = &quot;&quot;
  LET l_data.labels = &quot;&quot;
  LET l_data.nivel_servicio = &quot;&quot;
  LET l_data.fecha_reincidencia_1 = &quot;&quot;
  LET l_data.fecha_reincidencia_2 = &quot;&quot;
  LET l_data.fecha_reincidencia_3 = &quot;&quot;
  LET l_data.fecha_reincidencia_4 = &quot;&quot;
  LET l_data.sow3 = &quot;&quot;
  LET l_data.fecha_autorizacion = &quot;&quot;
  LET l_data.dias_autorizacion = &quot;&quot;
  LET l_data.raiz_wa = &quot;&quot;

  RETURN l_data.*
END FUNCTION
{&lt;/BLOCK&gt;} --fct.actividad_jira_setDefaultValuesFromDBSchema

--------------------------------------------------------------------------------
--Add user functions
{&lt;POINT Name=&quot;user.functions&quot;&gt;}
{&lt;/POINT&gt;}
</Generated>
<Diff/>
<Lost/>
</File>