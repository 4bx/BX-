#+ Data Management from DB schema (tecnoparque)

--------------------------------------------------------------------------------
--This code is generated by the 'dbxdata.tcl' template
--Warning: Enter your changes within a <BLOCK> or <POINT> section, otherwise they will be lost.
{<POINT Name="user.comments">}
{</POINT>}

--------------------------------------------------------------------------------
--Importing modules
IMPORT FGL tecnoparque_dbxconstraints
IMPORT FGL libdbappCommon
{<POINT Name="import">}
{</POINT>}

--------------------------------------------------------------------------------
--Database schema
SCHEMA tecnoparque

--------------------------------------------------------------------------------
--CRUD functions

{<BLOCK Name="fct.usuarios_selectRowByKey">}
#+ Select a row identified by the primary key in the "usuarios" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      usuarios_c_empresa LIKE usuarios.c_empresa,
      usuarios_nombre LIKE usuarios.nombre
    END RECORD
  DEFINE l_data RECORD LIKE usuarios.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM usuarios
    WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
      AND usuarios.nombre = p_key.usuarios_nombre
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{</BLOCK>} --fct.usuarios_selectRowByKey

{<BLOCK Name="fct.usuarios_insertRowByKey">}
#+ Insert a row in the "usuarios" table and return the primary key created
#+
#+ @param p_data - a row data LIKE usuarios.*
#+
#+ @returnType - INTEGER, SMALLINT, VARCHAR2(45)
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, usuarios.c_empresa, usuarios.nombre
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE usuarios.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_usuarios_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
    IF errNo == ERROR_SUCCESS THEN
      TRY
        INSERT INTO usuarios VALUES (p_data.*)
      CATCH
        LET errNo = ERROR_FAILURE
      END TRY
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.c_empresa, p_data.nombre
END FUNCTION
{</BLOCK>} --fct.usuarios_insertRowByKey

{<BLOCK Name="fct.usuarios_updateRowByKey">}
#+ Update a row identified by the primary key in the "usuarios" table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE usuarios.*
#+ @param p_dataT1 - a row data LIKE usuarios.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      usuarios_c_empresa LIKE usuarios.c_empresa,
      usuarios_nombre LIKE usuarios.nombre
    END RECORD
  DEFINE p_dataT0 RECORD LIKE usuarios.*
  DEFINE p_dataT1 RECORD LIKE usuarios.*
  DEFINE l_dataT2 RECORD LIKE usuarios.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != "SQT") THEN
        SELECT * INTO l_dataT2.* FROM usuarios
          WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
          AND usuarios.nombre = p_key.usuarios_nombre
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_usuarios_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE usuarios
            SET usuarios.* = p_dataT1.*
            WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
          AND usuarios.nombre = p_key.usuarios_nombre
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{</BLOCK>} --fct.usuarios_updateRowByKey

{<BLOCK Name="fct.usuarios_deleteRowByKey">}
#+ Delete a row identified by the primary key in the "usuarios" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      usuarios_c_empresa LIKE usuarios.c_empresa,
      usuarios_nombre LIKE usuarios.nombre
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM usuarios
        WHERE usuarios.c_empresa = p_key.usuarios_c_empresa
        AND usuarios.nombre = p_key.usuarios_nombre
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{</BLOCK>} --fct.usuarios_deleteRowByKey

{<BLOCK Name="fct.usuarios_setDefaultValuesFromDBSchema">}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_usuarios_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE usuarios.*

  INITIALIZE l_data.* TO NULL
  LET l_data.nombre = ""
  LET l_data.c_empresa = ""

  RETURN l_data.*
END FUNCTION
{</BLOCK>} --fct.usuarios_setDefaultValuesFromDBSchema

{<BLOCK Name="fct.empresas_selectRowByKey">}
#+ Select a row identified by the primary key in the "empresas" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      empresas_c_empresa LIKE empresas.c_empresa
    END RECORD
  DEFINE l_data RECORD LIKE empresas.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM empresas
    WHERE empresas.c_empresa = p_key.empresas_c_empresa
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{</BLOCK>} --fct.empresas_selectRowByKey

{<BLOCK Name="fct.empresas_insertRowByKey">}
#+ Insert a row in the "empresas" table and return the primary key created
#+
#+ @param p_data - a row data LIKE empresas.*
#+
#+ @returnType - INTEGER, SMALLINT
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, empresas.c_empresa
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE empresas.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_empresas_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
    IF errNo == ERROR_SUCCESS THEN
      TRY
        INSERT INTO empresas VALUES (p_data.*)
      CATCH
        LET errNo = ERROR_FAILURE
      END TRY
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.c_empresa
END FUNCTION
{</BLOCK>} --fct.empresas_insertRowByKey

{<BLOCK Name="fct.empresas_updateRowByKey">}
#+ Update a row identified by the primary key in the "empresas" table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE empresas.*
#+ @param p_dataT1 - a row data LIKE empresas.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      empresas_c_empresa LIKE empresas.c_empresa
    END RECORD
  DEFINE p_dataT0 RECORD LIKE empresas.*
  DEFINE p_dataT1 RECORD LIKE empresas.*
  DEFINE l_dataT2 RECORD LIKE empresas.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != "SQT") THEN
        SELECT * INTO l_dataT2.* FROM empresas
          WHERE empresas.c_empresa = p_key.empresas_c_empresa
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_empresas_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE empresas
            SET empresas.* = p_dataT1.*
            WHERE empresas.c_empresa = p_key.empresas_c_empresa
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{</BLOCK>} --fct.empresas_updateRowByKey

{<BLOCK Name="fct.empresas_deleteRowByKey">}
#+ Delete a row identified by the primary key in the "empresas" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      empresas_c_empresa LIKE empresas.c_empresa
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM empresas
        WHERE empresas.c_empresa = p_key.empresas_c_empresa
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{</BLOCK>} --fct.empresas_deleteRowByKey

{<BLOCK Name="fct.empresas_setDefaultValuesFromDBSchema">}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_empresas_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE empresas.*

  INITIALIZE l_data.* TO NULL
  LET l_data.c_empresa = ""
  LET l_data.empresa = ""

  RETURN l_data.*
END FUNCTION
{</BLOCK>} --fct.empresas_setDefaultValuesFromDBSchema

{<BLOCK Name="fct.carga_jira_selectRowByKey">}
#+ Select a row identified by the primary key in the "carga_jira" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      carga_jira_id_jira LIKE carga_jira.id_jira
    END RECORD
  DEFINE l_data RECORD LIKE carga_jira.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM carga_jira
    WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{</BLOCK>} --fct.carga_jira_selectRowByKey

{<BLOCK Name="fct.carga_jira_insertRowByKey">}
#+ Insert a row in the "carga_jira" table and return the primary key created
#+
#+ @param p_data - a row data LIKE carga_jira.*
#+
#+ @returnType - INTEGER, SERIAL
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, carga_jira.id_jira
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE carga_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL libdbapp_get_sequence("carga_jira") RETURNING errNo, p_data.id_jira
    IF errNo == ERROR_SUCCESS THEN
      CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_carga_jira_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
      IF errNo == ERROR_SUCCESS THEN
        TRY
          INSERT INTO carga_jira VALUES (p_data.*)
        CATCH
          LET errNo = ERROR_FAILURE
        END TRY
      END IF
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.id_jira
END FUNCTION
{</BLOCK>} --fct.carga_jira_insertRowByKey

{<BLOCK Name="fct.carga_jira_updateRowByKey">}
#+ Update a row identified by the primary key in the "carga_jira" table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE carga_jira.*
#+ @param p_dataT1 - a row data LIKE carga_jira.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      carga_jira_id_jira LIKE carga_jira.id_jira
    END RECORD
  DEFINE p_dataT0 RECORD LIKE carga_jira.*
  DEFINE p_dataT1 RECORD LIKE carga_jira.*
  DEFINE l_dataT2 RECORD LIKE carga_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != "SQT") THEN
        SELECT * INTO l_dataT2.* FROM carga_jira
          WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_carga_jira_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE carga_jira
            SET carga_jira.* = p_dataT1.*
            WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{</BLOCK>} --fct.carga_jira_updateRowByKey

{<BLOCK Name="fct.carga_jira_deleteRowByKey">}
#+ Delete a row identified by the primary key in the "carga_jira" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      carga_jira_id_jira LIKE carga_jira.id_jira
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM carga_jira
        WHERE carga_jira.id_jira = p_key.carga_jira_id_jira
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{</BLOCK>} --fct.carga_jira_deleteRowByKey

{<BLOCK Name="fct.carga_jira_setDefaultValuesFromDBSchema">}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_carga_jira_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE carga_jira.*

  INITIALIZE l_data.* TO NULL
  LET l_data.id_jira = ""
  LET l_data.key_ = ""
  LET l_data.issue_type = ""
  LET l_data.status_ = ""
  LET l_data.priority = ""
  LET l_data.summary = ""
  LET l_data.description = ""
  LET l_data.reporter = ""
  LET l_data.assignee = ""
  LET l_data.created = ""
  LET l_data.due_date = ""
  LET l_data.updated = ""
  LET l_data.resolved = ""
  LET l_data.labels = ""
  LET l_data.fecha_carga = ""
  LET l_data.hora_carga = ""

  RETURN l_data.*
END FUNCTION
{</BLOCK>} --fct.carga_jira_setDefaultValuesFromDBSchema

{<BLOCK Name="fct.actividad_jira_selectRowByKey">}
#+ Select a row identified by the primary key in the "actividad_jira" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, l_data
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_selectRowByKey(p_key)
  DEFINE p_key
    RECORD
      actividad_jira_key_ LIKE actividad_jira.key_
    END RECORD
  DEFINE l_data RECORD LIKE actividad_jira.*
  DEFINE errNo INTEGER

  INITIALIZE l_data.* TO NULL
  LET errNo = ERROR_SUCCESS
  TRY
    SELECT * INTO l_data.* FROM actividad_jira
    WHERE actividad_jira.key_ = p_key.actividad_jira_key_
  CATCH
    INITIALIZE l_data.* TO NULL
    LET errNo = ERROR_FAILURE
  END TRY

  RETURN errNo, l_data.*
END FUNCTION
{</BLOCK>} --fct.actividad_jira_selectRowByKey

{<BLOCK Name="fct.actividad_jira_insertRowByKey">}
#+ Insert a row in the "actividad_jira" table and return the primary key created
#+
#+ @param p_data - a row data LIKE actividad_jira.*
#+
#+ @returnType - INTEGER, VARCHAR2(45)
#+ @return - ERROR_SUCCESS|ERROR_FAILURE, actividad_jira.key_
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_insertRowByKey(p_data)
  DEFINE p_data RECORD LIKE actividad_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_actividad_jira_checkTableConstraints(FALSE, p_data.*) RETURNING errNo, errMsg
    IF errNo == ERROR_SUCCESS THEN
      TRY
        INSERT INTO actividad_jira VALUES (p_data.*)
      CATCH
        LET errNo = ERROR_FAILURE
      END TRY
    END IF
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF
  RETURN errNo, errMsg, p_data.key_
END FUNCTION
{</BLOCK>} --fct.actividad_jira_insertRowByKey

{<BLOCK Name="fct.actividad_jira_updateRowByKey">}
#+ Update a row identified by the primary key in the "actividad_jira" table
#+
#+ @param p_key - Primary Key
#+ @param p_dataT0 - a row data LIKE actividad_jira.*
#+ @param p_dataT1 - a row data LIKE actividad_jira.*
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_updateRowByKey(p_key, p_dataT0, p_dataT1)
  DEFINE p_key
    RECORD
      actividad_jira_key_ LIKE actividad_jira.key_
    END RECORD
  DEFINE p_dataT0 RECORD LIKE actividad_jira.*
  DEFINE p_dataT1 RECORD LIKE actividad_jira.*
  DEFINE l_dataT2 RECORD LIKE actividad_jira.*
  DEFINE errNo INTEGER
  DEFINE errMsg STRING
  DEFINE errDiff INTEGER

  INITIALIZE l_dataT2.* TO NULL
  INITIALIZE errMsg TO NULL
  LET errDiff = FALSE
  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      -- Concurrent Access done with the FOR UPDATE (not supported by SQLite)
      IF (UPSHIFT(fgl_db_driver_type()) != "SQT") THEN
        SELECT * INTO l_dataT2.* FROM actividad_jira
          WHERE actividad_jira.key_ = p_key.actividad_jira_key_
        FOR UPDATE
        LET errDiff = (p_dataT0.* != l_dataT2.*)
      END IF

      IF NOT errDiff THEN
        CALL tecnoparque_dbxconstraints.tecnoparque_dbxconstraints_actividad_jira_checkTableConstraints(TRUE, p_dataT1.*) RETURNING errNo, errMsg
        IF errNo == ERROR_SUCCESS THEN
          UPDATE actividad_jira
            SET actividad_jira.* = p_dataT1.*
            WHERE actividad_jira.key_ = p_key.actividad_jira_key_
        END IF
      ELSE
        LET errNo = ERROR_CONCURRENT_ACCESS_FAILURE
      END IF
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
    IF errNo == ERROR_SUCCESS THEN
      LET errNo = libdbapp_commit_work()
    ELSE
      CALL libdbapp_rollback_work()
    END IF
  END IF

  RETURN errNo, errMsg
END FUNCTION
{</BLOCK>} --fct.actividad_jira_updateRowByKey

{<BLOCK Name="fct.actividad_jira_deleteRowByKey">}
#+ Delete a row identified by the primary key in the "actividad_jira" table
#+
#+ @param p_key - Primary Key
#+
#+ @returnType - INTEGER
#+ @return - ERROR_SUCCESS|ERROR_FAILURE
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_deleteRowByKey(p_key)
  DEFINE p_key
    RECORD
      actividad_jira_key_ LIKE actividad_jira.key_
    END RECORD
  DEFINE errNo INTEGER

  LET errNo = libdbapp_begin_work()
  IF errNo == ERROR_SUCCESS THEN
    TRY
      DELETE FROM actividad_jira
        WHERE actividad_jira.key_ = p_key.actividad_jira_key_
    CATCH
      LET errNo = ERROR_FAILURE
    END TRY
  END IF
  IF errNo == ERROR_SUCCESS THEN
    LET errNo = libdbapp_commit_work()
  ELSE
    CALL libdbapp_rollback_work()
  END IF

  RETURN errNo
END FUNCTION
{</BLOCK>} --fct.actividad_jira_deleteRowByKey

{<BLOCK Name="fct.actividad_jira_setDefaultValuesFromDBSchema">}
#+ Set data with the default values coming from the DB schema
#+
PUBLIC FUNCTION tecnoparque_dbxdata_actividad_jira_setDefaultValuesFromDBSchema()
  DEFINE l_data RECORD LIKE actividad_jira.*

  INITIALIZE l_data.* TO NULL
  LET l_data.c_status = ""
  LET l_data.paso = ""
  LET l_data.key_ = ""
  LET l_data.issue_type = ""
  LET l_data.status = ""
  LET l_data.priority = ""
  LET l_data.summary = ""
  LET l_data.description = ""
  LET l_data.reporter = ""
  LET l_data.assignee = ""
  LET l_data.fecha_del_dia = ""
  LET l_data.fecha_creacion_created = ""
  LET l_data.fecha_inicio = ""
  LET l_data.dias_transcurridos_al_dia = ""
  LET l_data.fecha_prometida__vs_ns = ""
  LET l_data.fecha_prometida__due_date = ""
  LET l_data.dias_ret_vs_f_prom_ns = ""
  LET l_data.dias_ret_vs_f_prom_due_date = ""
  LET l_data.dias_brecha = ""
  LET l_data.fecha_cierre_resolved = ""
  LET l_data.cumplio_ns = ""
  LET l_data.cumplio_fp = ""
  LET l_data.dias_efectivos = ""
  LET l_data.labels = ""
  LET l_data.nivel_servicio = ""
  LET l_data.fecha_reincidencia_1 = ""
  LET l_data.fecha_reincidencia_2 = ""
  LET l_data.fecha_reincidencia_3 = ""
  LET l_data.fecha_reincidencia_4 = ""
  LET l_data.sow3 = ""
  LET l_data.fecha_autorizacion = ""
  LET l_data.dias_autorizacion = ""
  LET l_data.raiz_wa = ""

  RETURN l_data.*
END FUNCTION
{</BLOCK>} --fct.actividad_jira_setDefaultValuesFromDBSchema

--------------------------------------------------------------------------------
--Add user functions
{<POINT Name="user.functions">}
{</POINT>}
